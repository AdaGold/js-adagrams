# Screens
This is the game's "presentation layer". If you think of the app as following the [Model-View-Controller (MVC) pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller), the screens (and the [components](../components/) they depend on) contain the View and Controller. They contain the View in that they render the jsx that results in text showing up on the screen. They contain the Controller in that they register input-handling functions, which dispatch actions, in order to control the state in [gamestate](../gamestate). In fact, had the game's state, which is the Model, been simple enough, they would also have been the place where state is defined and stored.

## Following MVC
### MVC and the structure of files, functions, and classes
The prior statement is a big hint that "following the MVC pattern" does not mean separating files, or even classes, or even functions (!) into "model", "view", and "controller". Following the MVC pattern means:
1. A user manipulates some input device (mouse, keyboard, touch, microphone, etc.)
1. That input is interpreted by a controller, with enough additional information from the context of the running application, to modify an underlying "model".
1. The change made to the model is observed by a "view" layer, which takes the model changes and renders it into a form that an output device can interpret.
1. The rendered output is displayed to the user via some means (screen, printed document, audio output, tactile display, etc.).

<p><details>
  <summary>Expand for a deeper discussion on the nature and value of MVC.</summary>

The model is at the core, and around it, there are many many layers of Controller and View. They make the model available to the user, and allow the user to interact with it. The screens in this folder organize certain aspects of the application's overall View and Controller, segmenting them in a way that matches the developer's mental model of how the application is supposed to behave from a user perspective. The folders, files, and even the functions representing components, emerge out of this mental model of user interaction, rather than being organized around the View and Controller concepts themselves. That means that not every Ink app, and likely very few React apps, would have a "screens" folder. There are only "screen" components because the wireframes started with screens. React apps also wouldn't have "view" and "controller" folders; in React it is awkward to separate views from controllers cleanly. Doing so would make the code harder to understand. The View & Controller layer might have been organized differently, depending on what the original specifications had looked like.

Likewise, the "game state" model might not have been monolithic, global, and located in a single folder. There are some obvious seams in the game state where the state might be separated into different objects. Were the application to grow, it would benefit from refactoring to separate the state that changes independently, similar to how these screens are factored to display screens that are independent of each other from a View perspective.

If this leaves you feeling uncomfortable with how loose the MVC concept is as a pattern, you may prefer to instead think about what anti-patterns might emerge in your code, and what benefits you miss out on, if it isn't applied. The most common anti-pattern emerges when the Controller directly interacts with the View. Input directly controls output, without an observable model in between. It makes it harder to keep track of whatever information passes from input to output. It means that testing the system isn't possible without poking buttons and looking at the screen. Forcing data through a Model layer adds a lot of flexbility when it comes to extending and testing a UI system. The most obvious benefit comes from separating the Model from the View and Controller. Separating out a clear, but abstract, representation of the app's state and of the data that a user cares about, makes it much easier to move that state aroundâ€”keep track of previous state in order to undo actions, send the state to a server or to disk, etc. You can save the state so that the user can resume whatever they were doing if their application closed or disconnected. You can more easily create file saving code. And you can much more easily test your model without having to mock more complicated aspects of code like display or user input. While testing the demo game, the original developer took advantage of this. It has [a debug flag in its reducer](../gamestate/reducer.js#L12) that lets you go straight to a win screen with mock data. This sort of setting would be possible, but more difficult, had the model been spread throughout the application.

Separating the Model from other aspects of the application is so powerful that "Model" is the common theme when you compare MVC to other patterns that are intended to compete with or supersede it, such as [Model-View-ViewModel](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) (MVVM), [Model-View-Adapter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93adapter) (MVA), and [Model-View-Presenter](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter) (MVP). In fact, if you compare the data flow diagrams of all of these "patterns" to the data flow diagram of [the traditional 3-tier architecture](https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture), you might come to the conclusion that they're all fundamentally the same. People who discuss and theorize about software architecture seem to come back, again and again, to this idea. There is a model of a system at the center, which is stored in a way the computer can represent it. Changes to that model are organized by some layer that interprets user actions and forms them into functions that can operate on the model. When the model changes, calculations have to be made in order to return the updates back to the user. The various organizational models offer different advice and points of view on how the systems that interpret input or produce output ought to be organized or connected, but fundamentally the abstracted model of data is always at the center.
</details></p>

TL;DR: An observable model is key, and you have lots of flexibility in organizing the code that handles user input/output.

### Why screens?
These rough wireframes were used to guide development of the View. The "screens" concept evolved directly from the wireframes:

![This is a high level description of screens in the Adagrams application. Five screens are listed: Main Menu, How to Play, Set up game (with a name entry sub-screen), In-game, and Win Screen. All of the screens' layouts except for in-game are shown in this wireframe. The "Main Menu" screen has three options: Start New Game, How to Play, and Quit. "Start New Game" is highlighted. The "How to Play" screen provides the following explanation: "Select # and names of players. Each round, a new set of 10 letters is chosen. Every player has a certain number of seconds to guess. The winner is whoever has the highest score at the end of all rounds." The Set up Game screen has three areas to enter numbers: Number of players (1-4), Number of rounds, and Seconds per player per round. It lists initial values of 2, 3, and 15, respectively. 2 is highlighted. The player entry sub-screen of "Set up Game" prompts the user with "Player whatever, enter name". As an example of input, "Matt" is the name entered. The subs-screen is prescribed to show for each of the number of players entered in "Set Up Game". The In-Game screen is part of the next wireframe image and not present. Finally, the Win Screen shows that a message will display after the game is complete. The message is: "Player wins with Number points!", where Player and Number are placeholders for the winner and how many points they earned. Additionally, a list of players and the points they earned appears below.](../docs/screens-wireframe-1.png)
![This second wireframe displays the In-Game screen listed in the first wireframe. Along the top of the screen is an example Adagrams hand: I A H Z R D H E S G. The round number and time remaining are displayed below this. Then, each player name is displayed in its own column, with the first player highlighted. A note points out that the highlight indicates the current guesser. Below the first player, a guess, "DEAR" is shown, along with its score. Below that, a blank area is highlighted, and a note is attached: "Highlight where you're entering words." The second player column has a note that says: "Not allowed to guess another player's word." It also has a note that says: "Start here on next round", which means the wireframes suggest that the round following this one should start with the second, rather than first, player.](../docs/screens-wireframe-2.png)

It's worth mentioning that the final result does not implement these wireframes exactly. The rough, hand-drawn nature of these wireframes is a big hint that they are not intended to be a full specification, followed rigorously; they are merely a jumping-off point. That is exactly how development played out.

## Magic index.js
The root component of the screens, `ScreenDisplayer`, is inside of [index.js](./index.js). That lets the import statement in [app.js](../app.js) look a little magical:

```
import ScreenDisplayer from './screens';
```

JavaScript `import` knows to look for `index.js` when it's given a folder instead of a file, and that's how `App` ends up getting the `ScreenDisplayer` without mentioning "index" anywhere.

You can see the screens that have been implemented by looking at the logic inside of `ScreenDisplayer`.
